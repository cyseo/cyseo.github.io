---
layout: post
comments: true
title: "[JAVA] Effective java 11장"
author: Changyoun Seo
date: 2018-06-24 12:00:00 +0900
tags: [공부]
---

# 11장
## 규칙74. Serializable 인터페이스를 구현할 때는 신중하라
- Serializable을 구현한 클래스를 릴리즈하고 나면 구현을 유연하게 바꾸기 어렵다.
    - Serializable을 구현한 클래스의 바이트 스트림 인코딩도 공개 API의 일부가 되어버린다.
    - 나중에 해당 클래스를 변경할 경우 직렬화 형식에 호환 불가능한 변화가 생길 수 있다.
- 버그나 보안 취약점이 발생할 가능성이 높아진다.
    - 역직렬화는 생성자와 동일한 이슈를 가지고 있는 `숨은 생성자`이다.
    - 역직렬화 과정의 생성자가 명시적으로 존재하지 않으므로 불변식 보장, 불변접근 등의 문제에 쉽게 노출된다.
- 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.
    - 직렬화 후 역직렬화가 가능한지도 검사해야 한다. 각 릴리즈별로 상호 변환이 가능한지 체크해야하며 이런 테스트는 이진 호환성 외에 의미 호환성도 테스트해야 하기 때문에 자동화 할 수 없다.
- 계승을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 좋다.
    - 그렇게 구현된 클래스를 계승하거나 구현하는 개발자는 많은 부담을 떠안는다.
- 만약 Serializable을 구현하지 않기로 했고, 계승을 고려한 클래스라면 무인자 생성자를 제공하는 것이 어떨지 따져봐야 한다.
    - Serializable을 구현하지 않은 상위 클래스에 무인자 생성자가 없다면 직렬화 가능 하위 클래스의 구현은 불가능하다.
- 내부 클래스는 Serializable을 구현하면 안 된다. 내부 클래스의 기본 직렬화 형식은 정의될 수 없다.

## 규칙75. 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
- 기본 직렬화 형식은 그 객체의 물리적 표현이 논리적 내용과 동일할 때에만 적절하다.
    - 그렇지 않은 경우 기본 직렬화 형식을 그대로 받아들이면 안된다.
    - 불변식이나 보안조건을 만족시켜야 한다면 사용자 지정 직렬화 형식을 사용하는 것이 적절하다.

```java
// 이중 연결 리스트
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;
    
    private static class Entry implements Serializable {
        String data;
        Entry next;
        Entry previous;
    }
    
    // ...
}
```

- 객체의 물리적 표현과 논리적 표현이 다름에도 기본 직렬화 형식을 사용할 경우 몇 가지 문제가 생긴다.(위 예제)
    - 공개 API가 현재 내부 표현 상태에 영원히 종속된다. (Entry)
    - 너무 많은 공간을 차지하는 문제가 생길 수 있다. (모든 리스트 항목사이의 연결 정보가 들어가게 된다)
    - 너무 많은 시간을 소비하는 문제가 생길 수 있다. (많은 양의 그래프 순회가 이루어진다)
    - 스택 오버플로우 문제가 생길 수 있다. (기본 직렬화 절차는 재귀적인 객체 그래프 순회가 필요하다)
    
- `transient`는 기본 직렬화 형식에 포함되지 않음을 나타낸다.
- 객체의 모든 필드가 `transient`일 떄는 `defaultWriteObject`, `defaultReadObject`를 호출하지 않아도 되지만, 하는 것이 좋다.
- 객체의 논리적 상태를 구성하는 값이라는 확신이 들기 전까지는 `비-transient`필드로 만들겠다는 결정을 내리면 안된다.
    - 기본 직렬화 형식을 사용하는 경우 `transient`라벨이 붙은 필드들은 역직렬화 되었을 때 기본값으로 초기화된다.
    - 기본값이 할당되면 안되는 필드라면 지연 초기화나 readObject 메서드를 구현하여 적절히 복구하여야 한다.
- 어떤 직렬화를 사용하건 직렬화 가능 클래스를 구현할 때에는 직렬 버전 `UID`를 명시적으로 선언해야 한다.
    - UID 계산 시간을 줄일 수 있다.
    - 잠재적 호환성 문제가 사라진다.

- +) `@serial`, `@serialData`태그는 Javadoc유틸리티에 직렬화 형식을 다루는 특별한 문서로 분리하라는 지시를 내린다.

## 규칙76. readObject 메서드는 방어적으로 구현하라
- `readObject` 메서드는 실질적으로 public 생성자나 마찬가지다.
    - 생성자와 같은 이슈가 발생한다. 신중하게 작성하지 않으면 공격자가 쉽게 클래스의 불변식을 망가뜨릴 수 있게 된다.
    - 인자의 유효성을 검사해야 한다.
    - 필요하다면 인자를 방어적으로 복사해야 한다.
- 객체를 역으로 직렬화할 때는 클라이언트가 가질 수 없어야 하는 객체 참조를 담은 모든 필드를 방어적으로 복사해야 한다.
- 릴리즈 1.4에 추가된 방어적 복사 없이 악의적 객체 참조 공격을 막을 수 있도록 고안된 `writeUnshared`와 `readUnshared` 메서드는 사용하면 안된다. 필요한 안전성을 제공하지 못한다.
- 안전한 `readObject` 메서드를 구현하기 위한 체크리스트
    - private로 남아있어야 하는 객체 참조 필드를 가진 클래스는 그런 필드가 가리키는 객체를 방어적으로 복사해야 한다.
    - 불변식을 검사해서 위반된 사실이 감지되면 `InvalidObjectException`을 던져라. 불변식 검사는 방어적 복사 이후에 시행해야 한다.
    - 객체를 완전히 역직렬화 한 후에 전체 객체 그래프의 유효성을 검사해야 한다면 `ObejctInputValidation` 인터페이스를 이용하라.
    - 직접적이건 간접적이건 재정의 가능 메서드를 호출하지 마라.
    
## 규칙77. 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
- `implements Serializable`를 붙이는 순간 싱글톤 클래스는 싱글톤이 아니게 된다.
- 역직렬화할 클래스에 `readResolve` 메서드가 정의되어 있다면 역직렬화가 끝나서 만들어진 객체에 대해 해당 메서드가 호출된다. 이를 이용해 싱글톤을 유지할 수 있다.
- 개체 통제를 위해 `readResolve`를 활용하는 경우 객체 참조 자료형으로 선언된 모든 필드를 `transient`로 선언해야 한다.
    - 그렇지 않다면 `readResolve`가 실행되기 전에 역직렬화된 객체에 대한 참조를 가로챌 수 있게 된다.
- 가장 좋은 방법은 enum을 사용해 싱글톤을 구현하는 것이다. 이렇게 하면 선언된 상수 이외의 다른 객체는 존재할 수 없다는 확실한 보장이 생긴다.

## 규칙78. 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
- Serializable 인터페이스를 구현하는 것은 버그나 보안 결함이 생길 위험이 있으므로 그 대신 `직렬화 프락시 패턴`을 사용할 수도 있다.
    1. 바깥 클래스(=A) 객체의 논리적 상태를 간결하게 표현하는 직렬화 가능 클래스를 private static 중첩 클래스(=B)로 설계한다.
    2. B는 A 자료형을 사용하는 생성자 하나만 가진다.
    3. 이 생성자에서 데이터를 복사한다. 일관성, 방어적 복사도 필요 없다.
    4. A에 `writeReplace`메서드를 사용해 `return new B(this)`형태로 B를 반환한다. 이렇게 하면 직렬화 시스템은 A의 직렬화된 객체는 만들지 않는다.
    5. A에 `readObject`를 구현하고, 무조건 Exception을 발생하게 한다. 이렇게 하면 클래스의 불변식을 훼손하려는 시도를 막을 수 있다.
    6. B에 자기와 논리적으로 동일한 A를 반환하는 `readObject` 메서드를 추가한다. 직렬화 시스템은 역직렬화를 끝내자 마자 B를 A로 변환하게 된다.
    
- `직렬화 프락시 패턴`의 특징은 다음과 같다.
    - 직렬화의 언어 외부적 특성이 대부분 제거된다. 덕분에 역직렬화된 객체가 불변식을 준수하도록 별도의 수단을 동원할 필요가 없다.
    - 역직렬화된 객체가 애초에 직렬화된 객체와 다른 클래스가 되도록 할 수도 있다.
- 제약사항은 다음과 같다.
    - 클라이언트가 확장 할 수 있는 클래스에는 적용할 수 없다.
    - 객체 그래프에 순환 구조가 있다면 사용할 수 없다.
