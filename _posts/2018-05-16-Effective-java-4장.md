---
layout: post
comments: true
title: "[JAVA] Effective java 4장"
author: Changyoun Seo
date: 2018-05-16 12:00:00 +0900
tags: [공부]
---

# 4장 클래스와 인터페이스
## 규칙 13. 클래스와 멤버의 접근 권한은 최소화하라
- 정보은닉, 캡슐화 개념. 당연하다
- API 등을 public으로 까버리면 그건 약속이라 내내 유지해야 한다
- instance field 는 절대 public이면 안되고, 예외로는 public static final 인데, 이것마저도 변경 불가여야 한다.
- public static final 이 array 인 경우 값을 고칠 가능성이 있으므로 다음과 같이 처리하자
```java
private static final Thing[] PRIVATE_VALUE = { ... }; // private 로 접근을 막아버리고
pulbic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUE));
```

## 규칙14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라
- 당연

## 규칙15. 변경 가능성을 최소화하라
- 변경 불가능 클래스
    - 객체의 상태를 변경하는 세터 제공x
    - 계승 불가
    - 모든 필드 final
    - 모든 필드 private
    - 내부에 변경 가능한 친구가 있다면 본인만 접근 가능해야 한다
    
- 함수형 접근법: 값이 바뀌는게 아니라 새로운 상태의 새 객체를 반환 
- 단순한 만큼 장점이 많다
    - 스레드 안전, 자유롭게 공유 가능
    - 내부도 공유할 수 있고 다른 객체의 구성요소로도 좋다(맵의 key 역할)
- 단점
    - 값마다 별도의 객체를 만들어야 함 -> 이는 캐싱, 메모리제이션을 통해 약간 해결 가능

- 계승을 불가능하게 하기 위해 final class 혹은 private 생성자 + public 정적 팩토리를 제공할것
    
- 이게 모손소리야.
`성능 향상을 위해 다단계 연산 가운데 자주 요구되는 것을 기본 연산으로 제공하는 것이다. 그렇게 하면 변경 불가능 클래스는 단계별로 별도 객체를 만들 필요가 없다`

- 변경 가능한 클래스로 만들어야할 타당한 이유가 없다면 반드시 변경 불가 클래스로 만들 것

## 규칙16. 계승하는 대신 구성하라
- 계승은 캡슐화 원칙을 위반한다.
- 상속을 사용하면 상위 클래스가 변동될 떄마다 하위 클래스에 영향이 미칠 수 있어 안전하지 않다.
- 하위 클래스가 상위 클래스의 상태를 직접 변경하여 불변식을 깰 수도 있다.

- 구성을 사용하면 위와 같은 문제들을 해결할 수 있다.
- 새로운 클래스에 기존 클래스를 담을 수 있는 private 객체를 만들어 wrapping한다.
- 역호출 프레임워크에서는 문제가 될 수 있다는데,, 잘 모르겠다.

## 규칙17. 계승을 위한 설계나 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
- 다른 프로그래머가 보고 잘 쓸 수 있도록 하라는 것
- 반대로 이런 설계나 문서가 없는 클래스는 계승하지 말자. 분명 문제가 생긴다
- 계승을 위한 클래스를 테스트하는 좋은 방법은 직접 계승해 보는 것
    - 한 3개쯤
    - 딴사람이 만들어 보기도 하고
    - 필요한데 private라면 열고, 안쓰는데 protected라면 닫을 수 있을 것이다
- 생성자는 재정의 가능 메서드를 호출해서는 안된다
    - 상위 클래스 생성자가 먼저 호출되기 때문에 하위 클래스 생성자가 호출되는 사이에 재정의한 메서드가 호출되면 의도한 대로 동작하지 않을 것
    
## 규칙18. 추상 클래스 대신 인터페이스를 사용하라
- 추상 클래스는 구현된 메서드를 포함하므로 이를 사용하기 위해 반드시 계승해야 한다. 계승의 단점은 위에서 말했다.
- 하지만 인터페이스를 그러지 않아도 되고, 비 계층적이다(수평적 관계). 또한 구성을 통해 기능 기선이 가능하다.
- 골격 구현 이야기가 있는데 잘 이해는 안된다. 미리 구현될 필요가 있는 친구들이 필요할 때도 인터페이스로 해결가능하다!라고 해놓고 결국 추상클래스를 쓰고 있는데 흠터레스팅 나중에 다시 보자
- 인터페이스가 공개된 후에는 수정이 거의 불가능하므로 신중설계

## 규칙19. 인터페이스는 자료형을 정의할 때만 사용하라
- 인터페이스를 구현해 클래스를 만든다는 것은 해당 클래스의 객체로 어떤 일을 할 수 있는지 알리는 행위
- 이 경우 이외의 경우로 인터페이스를 사용해서는 안된다.
- 상수들이 필요할 때는 인터페이스에 넣지 말고 객체 생성이 불가능한 유틸리티 클래스에 넣자

## 규칙20. 태그 달린 클래스 대신 클래스 계층을 활용하라
- 한 클래스에서 원과 사각형을 모두 표현하는 케이스: 이런 쓰잘데기 없는건 계층을 활용하자. 필요 없는 필드를 표현하느라 메모리 낭비에, switch에 오류 발생가능성도 높고 밖에서 봤을때 무슨짓을 하는지도 모르겠고 초기화 전에는 값도 없어서 final 필드로 선언도 못한다.
- 클래스 계층을 사용하려면
    - 공통적으로 달라지는 부분만 빼서 최상위 abstract로 놓고
    - 독립적인건 알아서 가진 채로 abstract를 상속받아 구현하면 된다.

## 규칙21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라
- predictor 같은건데.. functional 이라면 익듁한 친구들. 근데 자바도 이제 람다 되잖아

## 규칙22. 멤버 클래스는 가능하면 static으로 선언하라
- 중첩 클래스에는 4가지 종류가 있다. 정적 멤버, 비-정적 멤버, 익명, 지역. 익명이야 규칙20과 함께 케빈TV에서 잘 다뤄서 생략하고, 잘 안쓰는 지역도 생략
- 내부 클래스가 바깥 클래스에 접근할 필요가 없다면 무조건 비정적으로 선언해서 바깥을 참조하지 않도록 하자.
- 참조할 필요가 있다면(this 한정 구문: Outer.this.fieldName..등을 사용하여) 비-정적으로
- private 정적 메소드는 바깥 클래스 객체의 컴포넌트 역할을 할때 적절하다. Entry 같이
